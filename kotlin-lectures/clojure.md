## Clojure

Нишевый язык. Аналог Lisp/Scheme/Racket
* Программа - S-выражение
* Можно работать как с данными

`Hello world`
```Clojure
(println "Hello")
(def x 23)
(println x)
```

* Синтаксис предельно прост - все выражается списками
* Список - это перечень элементов в скобках
* Шаг вычисления тоже представлен списком
* Ключевой элемент семантики - вызов функции 
* Оформление кода в программу тоже делается в стиле S-выражений
* Единица декомпозиции кода - namespace (аналог модуля)

```Clojure
(ns examples.Hello
    (:gen-class))
(println "Hello World")
```

Всё что есть в Java мы можем вызывать в Clojure\
`(. (. System (getProperties)) (get "os-name")) ~~ System.getProperties.get("os-name")`\
Создание объекта класса java.io.FileInputStream
`(new java.io.FileInputStream "abc")`

* Оператор ~ функция
* Многократное применение оператора можно сокращать `(- (+ a 6 b 10) d e)`

Блоки
```Clojure
(if false
    "nope")
; => nil

(if true
    (do (println "Success!")
        "it is true")
    (do(println "Failure!")
        "it is false"))
        
(when true
    (println "Success!")
    "abra cadabra")
```

Keyword
```Clojure
(type 0) // java.lang.Long
(type "abc") // java.lang.String
(type :abc) // clojure.lang.Keyword
```

Числа
* Аналоги JVM-целых
* Местами с плавным переходом в BigInt
* Числовой литерал трактуется как Long, если влезает иначе BigInt
* Явное приведение - `(short 123)`
* Операции типа (*' переходят в BigInt
* abs для Long/MAX_VALUE работает "как в Java"
  * abs' из коробки отсутствует

Символы - универсальное понятие
* def привязывает символ к объекту
* Объектом может быть число, строка, функция 
* Символ может включать в себя знаки операций
* Операции - тоже символы, привязанные к реализации
* И их можно переприсваивать (Точнее стандартные операции)
  * определены как `clojure.core.+` и т.п.
  * А просто `+` - локальный алиас

```Clojure
(def :+: +)
(def + -)
(println (+ 5 3)) // = 8
(println (:+: 5 3)) // = 2 
(println (clojure.core+ 5 3)) // 8
(def + :+:)
(println (+ 5 3)) // 8
```

Quote
* отменяет интерпретацию аргумента как выражения
* Можно применить к списку в круглых скобках и получить именно список, вместо попытки вызвать функцию
* A eval может исполнить список, хранящийся в переменной


* vector ~ список
* `conj [...] ...` - добавить
* #{:b ":b" :a} - множество
* `(:a #a :b})` - по сути функция (get) 


Строки
* В основе - JVM-строка задекорирована под clojure-стиль
* Функции сильно напоминают методы java.lang.String
* "Списочный" интерфейс тоже есть
* Ho (rest "hello") не идентично другому (rest "hello")


Определения функций
* Тоже в S-выражение 
* Первый элемент - defn. Второй элемент - перечень символов в квадратных скобках
  * Это имена параметров
* Потом идет тело функции как S-выражение
* Его результат - результат функции
* Никакой типизации параметров\
`(def *5 [n] (* 5 n))`
* рекурсия есть 

Факториал. Хвостовая рекурсия
```Clojure
(defn ! [n]
    (loop [cnt n 
           acc 1]
        (if (< cnt 2) acc 
            (recur (dec cnt) (* cnt acc) ))))
```


Можно разное число аргументов
```Clojure
(defn multi-arity
// 3-arity arguments and body 
    ([first-arg second-arg third-argl] (do-things first-arg second-arg third-arg))
// 2-arity arguments and body 
    ([first-arg second-argl] (do-things first-arg second-arg))
// 1-arity arguments and body 
    ([first-argl] (do-things first-arg)) 
```

А еще так можно в списке аргументов можно указать & и следом ровно одно имя
* Первые параметры попадут в указанные до &
* Все остальные - в указанный после


Анонимная функция 
```Clojure
((fn [name] (str "Hi, " name)) 8 ) // применили к 8
#(* % 3) // % - подстановка параметра
```

Список
* Функциональный спискок, голова и хвост
* list - литеральный конструктор
* list* - наращивающий конструктор
* first/rest - голова/хвост
* empty? - пусто ли?


seq, lazySeq
* Абстракция последовательности
* map, filter порождают LazySeq
* Seq - обертка для входа таких функций
* Есть бесконечные последовательности
* `doseq` - исполнить последовательность выражений


Аргументы командной строки можем получить в специальной переменной `*command-line-args*` в форме списка строк\
Файлы
* Своя обертка для JDK
* B clojure/io Можно читать/писать целиком, а можно по строчкам


### Концепции
* Вот у нас такой минималистский подход
* Функция - атомарная сущность, из которой все строится
* Что-то, что не принято считать функцией - оказалось функцией (операторы)
* А как насчет if или defn?
* Проблемы
  * Первая - надо посчитать аргументы
  * Она более или менее решаема. Ленивое вычисление можно смоделировать. Например, через quote
  *  Но страдает usability и остается другая проблема


Модель исполнения кода на Clojure состоит из Reader и Evaluator
* Reader: читает S-выражения в строковой форме и порождает списки
* "Встроенно" работает, но его логика доступна через функцию read-string
* Кроме синтаксиса S-выражений она учитывает некоторые макро-символы
  * Это называется "reader macros". Не путаем с "просто" макросами
* Его вообще можно модифицировать, чтобы писать свой if/defn


Evaluator
* Почти все превращается само в себя
* Исключение 1: Символы
  * Для символа ищем специальную форму (кроме некоторых контекстов)
  * Если не нашли - ищем let-определения
  * Если не нашли - ищем def-определения
* Исключение 2: Списки 
  * Список пытаемся "исполнить"
  * Пытаемся первый элемент вызвать как функцию
  * Остальные - передать как параметры
  * Если только это не специальная форма


Специальная форма
* "Встроенная" конструкция
* Внешне напоминает функцию, но ее параметры не вычисляются
* И она может иметь доступ к внутренности интерпретатора
* def, if, do, let, quote, fn, loop, recur, try, еще кое-что
* Имея их можно написать самому все остальное


В воздухе витает идея: программно поманипулировать списочной формой\
Макросы
* механизм, который позволяет вставлять свои преобразователи списков
* Приблизительно можно считать специальные формы "встроенными макросами" 
  * с привелегированным доступом к внутренностям системы

```Clojure
(defmacro backwards 
    [form]
    (reverse form))
    
(defmacro naive_infix
    "Use this macro when you pine for the notation of your ch 
    [infixedl]
    (list (second infixed) (first infixed) (last infixed)))
```

delay - позволяет в контексте определить действие, но дернуть ее попозже

## Делегирование

Проблема в том что наследование сложное, объектов/свойств много и делить их сложно\
Это можно решать с помощью интерфейсов. Создавать интерфейсы для смысловых групп атрибутов/поведения.
Что-то вроде Runnable, Chargable, Storable, Observable. \
Но если этим ограничиться - может потребоваться писать повторяющиеся реализации\
А если ограничиться реализацией по умолчанию в интерфейсе - не получится наследовать разное поведение от разных объектов


Один из вариантов решения:\
Можем принимать в конструкторе ссылки на другие объекты, в реализации методов интерфейсов ставить вызов метода другого объекта\
Это нормально работает, но требует boilerplate-кода\
Kotlin поддерживает этот шаблон в языке

`Interface by mуthod` рассказывает как должен быть реализовон вот этот объект от которого мы наследуемся
```kotlin
class TinAger(override val name: String, fundProvider: Chargeable): Named, Chargeable by fundProvider 
```


Минусы. Иногда абстрактный класс будет лучше
* При наследовании метод суперкласса может реализовать крупную схему поведения
* Для элементов которой вызывать другие protected-методы либо абстрактные, либо переопеределяемые
* В делегировании это сложно


### Nullable
* В JVM ссылочный тип может хранить null 
* Попытки его разыменовать порождают исключение
* Проблема 1: это происходит во время исполнения
* Проблема 2: диагностика часто не дает понимания

Решения
* проверки: одинаковые, плохо проверяются
* Option-типа в двумя вариантами: Some(value) и None: Следит за null проверками статически, стыкуется с generic
* В Котлин: Для каждого типа есть nullable-модификация 
  * Обозначается знаком вопроса после типа: T? ; String? - обнуляемая строка
  * Смысл в том, чтобы изолировать преобразования типов данных


Варианты работы
* При явной проверке на null в ветке, где значение гарантированно не null
  * рассматривается как значение обычного типа 
  * С теми же оговорками, как для умного приведения 
* Safe call (?.) - проверка на null и обращение к методу/свойству, если не null: `order?.date?.month`


### Let
* стандартное расширение
* Применение блока к данному объекту. Результат блока - результат let. Часто - с Unit-результатом
* Идиоматично применяется в связке с safe call
```kotlin
name?.let { println("Длина имени: ${it.length}") }
//    Или напечатает или пропустит блок, если name == null
```


* run - синоним let
* also - forEach для одного
* apply - примерно как also, только не-null значение предстает как this
* ?.takeIf - дополнительная фильтрация, если не выполнено условие, получаем null. Прочитает строку как целое


* Есть отдельная конструкция - (!!) Принудительное приведение nullable в обычный тип
* Вообще она не очень хорошая. Есть специальные filterNotNull и mapNotNull


Плюсы
* Концептуальная близость JVM-терминологии 
* Отсутствие runtime-издержек 
Минус
* изобретение велосипеда относительно Option-модели
* "угловатость" конструкций, невписываемость в обобщаемые модели 
* неразличение "порядка" отсутствия


### Generic
Java без legacy

Применяется к классам и статическим функциям/методам. Угловые скобки как в java

Отличия
* Все применения generic-типа требуют указания типа (Нет legacy-варианта "generic без типовых параметров")
* intHolder2/stringHolder2 - это просто type inference. Так уже нельзя: `var intHolder2: Holder`


Generic method
* У них могут быть свои типы-параметры
* И типы-параметры объемлющего класса
* При совпадении имен внутреннее приоритетнее внешнего 
* В функциях могут определяться локальные классы с параметрами-типами или в локальных классах использоваться тип функции
```kotlin
fun <T> f(s: T): Callable<List<T>> {
    class C(private val v: T) : Callable<List<T>> {
        override fun call(): List<T> = listOf(v, v)
    }
    return C(s)
}
```

Никто не запрещает generic в расширениях, в том числе в составе параметра и в качестве расширяемого типа
```kotlin
fun <T> T.printIf(f: (T) -> Boolean) { 
    if (f(this)) { println(this) } 
}
```
* Конкретные расширения имеют приоритет над обобщенными
* Если возникает неоднозначность - ошибка компиляции
* Если дважды встречается один тип-параметр - подразумеваются значения одного типа 
  * Если в реальности разные - ищется общий
* Тип T и T? в рамках generic - совпадают
  * Можно получить двойной Nullable если подставить в T? <- String?


Nothing
* отдельный тип
* Одна из интерпретаций - тип вычисления, которое не завершится
* Надо какой-то тип подставить, но по сути - нам все равно
* Формально он приводим к любому типу
* Можно объявить функцию как что-то возвращающую - и при этом бросить исключение
* Обратно - привести нельзя. Нельзя объявить функцию как возвращающую Nothing


Option, out T, Nothing\
В Kotlin модификаторы in и out используются для работы с **ковариантностью** и **контравариантностью** при определении 
обобщённых классов и интерфейсов.

out — ковариантность\
Модификатор out указывает, что обобщённый тип может использоваться только в выходных (output) позициях, например, в 
возвращаемых значениях методов.\
Ковариантность позволяет передавать объект класса с более узким типом туда, где ожидается более общий тип.

in — контравариантность\
Модификатор in указывает, что обобщённый тип может использоваться только во входных (input) позициях, 
например, в параметрах методов.\
Контравариантность позволяет передавать объект класса с более общим типом туда, где ожидается более узкий тип.


### Inline
inline перед функцией - функция вставляется прямо в место вызова.
* По умолчанию lambda-параметры - тоже
* Можно индивидуально ограничить - через ключевое слово noinline, перед каждый параметром индивидуально
* Имеет смысл сделать лямбду noinline если мы передаем ее как параметр и у нее нет состояний
`inline fun vvv(v: Int, noinline action: () -> Unit)... funfun(action)` если `funfun` - noinline 

Прикол с inline, return и fold\
Вообще return из лямбд делать нельзя
```kotlin
// fold - inline поэтому можно return и он осмысленен
inline fun List<Int>.prod(): Int {
    return this.fold(1) { curr, acc ->
        println("curr: $curr")
        if (curr == 0) return 0
        curr * acc
    }
}
```

* Плюсы: существенное ускорение
* Минусы: увеличение байткода
* разрешается return из lambda (имеет смысл только потому что там inline)
* Можно использовать для оптимизации, можно обжечься


Reified\
reified (реализованные) типы позволяют работать с generic на этапе выполнения (runtime), 
что обычно невозможно в Java из-за стирания типов. 

В inline функциях можно. `inline fun<reified T>.. t is T`. Иначе `t is T` нельзя проверить